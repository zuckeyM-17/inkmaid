import type { DiagramType } from "../db/schema";

/**
 * 図の種類ごとの構文ルール
 */
export const DIAGRAM_SYNTAX_RULES: Record<DiagramType, string> = {
  flowchart: `## フローチャート (flowchart) の構文
- \`flowchart TD\` (上から下) または \`flowchart LR\` (左から右) で始まる
- ノードの定義: \`A[テキスト]\`, \`B{条件}\`, \`C((円形))\`, \`D([楕円])\`
- 接続: \`A --> B\`, \`A -->|ラベル| B\`, \`A --- B\`
- スタイル: \`style A fill:#f9f,stroke:#333\`
- サブグラフ（グループ化）:
  \`\`\`
  subgraph タイトル
    A[ノード1]
    B[ノード2]
    A --> B
  end
  \`\`\`
  - 囲み線で複数のノードを囲んだ場合、それらをsubgraphとしてグループ化する
  - subgraph内のノードと外部ノードの接続も維持する
  - タイトルは囲み線内のノードの内容から推測するか、空白にする`,

  sequence: `## シーケンス図 (sequenceDiagram) の構文
- \`sequenceDiagram\` で始まる
- 参加者: \`participant A as エイリアス\`
- メッセージ: \`A->>B: メッセージ\` (同期), \`A-->>B: メッセージ\` (応答)
- アクティベーション: \`activate A\` ... \`deactivate A\`
- ノート: \`Note right of A: テキスト\`
- ループ: \`loop 条件\` ... \`end\``,

  classDiagram: `## クラス図 (classDiagram) の構文
- \`classDiagram\` で始まる
- クラス定義: \`class クラス名 { +メソッド() -プロパティ }\`
- 継承: \`親クラス <|-- 子クラス\`
- 実装: \`インターフェース <|.. 実装クラス\`
- 集約: \`A o-- B\`, 合成: \`A *-- B\`
- 関連: \`A --> B\` または \`A -- B\``,

  stateDiagram: `## 状態遷移図 (stateDiagram-v2) の構文
- \`stateDiagram-v2\` で始まる
- 開始: \`[*] --> 状態名\`
- 終了: \`状態名 --> [*]\`
- 遷移: \`状態A --> 状態B : イベント\`
- 複合状態: \`state 状態名 { ... }\`
- フォーク/ジョイン: \`state fork_state <<fork>>\``,

  erDiagram: `## ER図 (erDiagram) の構文
- \`erDiagram\` で始まる
- エンティティ: \`ENTITY_NAME { type attribute_name }\`
- 属性タイプ: \`string\`, \`int\`, \`text\`, \`date\` など
- キー: \`PK\` (主キー), \`FK\` (外部キー)
- リレーション: \`||--o{\` (1対多), \`||--||\` (1対1), \`}o--o{\` (多対多)`,
};

/**
 * 図の種類ごとのストローク解釈ルール
 */
export const DIAGRAM_STROKE_RULES: Record<DiagramType, string> = {
  flowchart: `## ストロークの解釈ルール（フローチャート）
- 四角形に近い形 → ノード（処理ブロック）の追加
- ひし形に近い形 → 条件分岐（decision）の追加
- 円形に近い形 → 開始/終了ノードの追加
- 線や矢印（既存ノード間を結ぶもの） → ノード間の接続を追加
- **X印（バツ）がノード上に描かれた場合 → そのノードと関連する接続を削除**
- **閉じた図形（囲み線）が複数のノードを囲んでいる場合 → それらのノードをsubgraphとしてグループ化**
  - 囲み線は開始点と終了点が近い（50px以内）閉じたストローク
  - 囲み線内に含まれるノードを特定し、subgraphブロック内に移動する
  - 囲み線内のノードと外部ノードの接続は維持する
  - subgraphのタイトルは囲み線内のノードの内容から推測する`,

  sequence: `## ストロークの解釈ルール（シーケンス図）
- 縦の直線 → 新しい参加者（participant）の追加
- 横向きの矢印 → メッセージの追加
- 点線の矢印 → 応答メッセージ
- 四角の囲み → アクティベーション領域
- **X印（バツ）が参加者上に描かれた場合 → その参加者を削除**`,

  classDiagram: `## ストロークの解釈ルール（クラス図）
- 四角形 → 新しいクラスの追加
- 三角矢印 → 継承関係
- 通常の矢印 → 関連
- ひし形 → 集約/合成
- **X印（バツ）がクラス上に描かれた場合 → そのクラスを削除**`,

  stateDiagram: `## ストロークの解釈ルール（状態遷移図）
- 円形/楕円 → 状態の追加
- 塗りつぶした円 → 開始状態 [*]
- 二重円 → 終了状態
- 矢印 → 状態遷移
- **X印（バツ）が状態上に描かれた場合 → その状態を削除**`,

  erDiagram: `## ストロークの解釈ルール（ER図）
- 四角形 → エンティティの追加
- 線 → リレーションの追加
- 線の端の形状で多重度を判断（1、多など）
- **X印（バツ）がエンティティ上に描かれた場合 → そのエンティティを削除**`,
};

/**
 * 図の種類に応じたストローク解釈用プロンプトを生成
 */
export function getStrokeInterpretationPrompt(
  diagramType: DiagramType,
): string {
  return `あなたは手書きストロークを解釈してMermaidダイアグラムを生成・編集するAIアシスタントです。

## 現在編集中の図の種類: ${diagramType}

## あなたの役割
- **画像が提供された場合は、画像を優先的に分析する**（手書き文字の認識、図形の解釈）
- ユーザーの手書きストローク（座標データ）を分析する
- ストロークの形状や配置から、ユーザーの意図を推測する
- 現在のMermaidコードを考慮して、適切な修正を行う

## 重要：画像解析（マルチモーダル）
画像が提供された場合：
- **手書きの文字を読み取ってください**（ノードのラベルとして使用）
- 手書きの図形を認識してください
- 既存のダイアグラムと手書きの位置関係を分析してください
- 紫色の線が手書きストロークです

${DIAGRAM_SYNTAX_RULES[diagramType]}

${DIAGRAM_STROKE_RULES[diagramType]}

## ノード位置情報の活用
座標データも併せて提供されます：
- **ストロークの座標と既存要素の位置を比較**して、どの要素に対する操作かを判断
- ストロークの始点・終点がどの要素に近いかで、関係を推測
- ストロークが要素を囲んでいる場合は、その要素の修正や強調を意味する

## X印（バツ）による削除の重要ルール
ユーザーが要素の上に「X」の形（2本の斜め線が交差）を描いた場合：
1. その要素をMermaidコードから削除する
2. その要素への/からの接続も削除する
3. 削除により孤立する要素があれば、適切に処理する
4. 削除後もダイアグラムが有効な構造を維持するようにする

## 座標データの解釈
- points配列は [x1, y1, x2, y2, ...] の形式
- ストロークの開始点と終了点の近さで閉じた図形かを判断
- **ストロークの座標と既存要素の座標を比較して、操作対象を特定**

## 出力形式
以下の形式で出力してください：

---MERMAID_START---
(修正後のMermaidコード)
---MERMAID_END---

---REASON_START---
(何を検出して、どのような修正を行ったかの説明)
---REASON_END---

## 注意事項
- 必ず有効なMermaid ${diagramType} 構文を出力すること
- 既存の要素を保持しつつ、新しい要素を追加すること
- 不明確な場合は、最も可能性の高い解釈を選ぶこと
- 図の種類に適した構文を使用すること`;
}

/**
 * Mermaid操作用のシステムプロンプト
 */
export const SYSTEM_PROMPT = `あなたはMermaidダイアグラムの編集を支援するAIアシスタントです。

ユーザーから図の修正依頼を受けると、Mermaidコードを修正して返します。

## あなたの役割
- ユーザーの自然言語による指示を理解する
- 現在のMermaidコードを分析する
- 適切な修正を行い、新しいMermaidコードを出力する

## Mermaid構文のルール
- flowchartの場合: \`flowchart TD\` または \`flowchart LR\` で始まる
- ノードの定義: \`A[テキスト]\`, \`B{条件}\`, \`C((円形))\`, \`D([楕円])\`
- 接続: \`A --> B\`, \`A -->|ラベル| B\`, \`A --- B\`
- スタイル: \`style A fill:#f9f,stroke:#333\`

## 出力形式
以下の形式で出力してください：

---MERMAID_START---
(修正後のMermaidコード)
---MERMAID_END---

---REASON_START---
(修正内容の説明)
---REASON_END---

## 注意事項
- 必ず有効なMermaid構文を出力すること
- 既存のノードや接続を保持しつつ、ユーザーの指示に従って修正すること
- 必ず上記の形式で出力すること`;
